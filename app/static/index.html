<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multimodal RAG Study Desk</title>
    <style>
        body {
            font-family: sans-serif;
            max-width: 960px;
            margin: auto;
            padding: 24px;
            background: #f7f9fc;
        }
        h1 {
            margin-bottom: 8px;
        }
        .section {
            background: #fff;
            border: 1px solid #d8dee9;
            border-radius: 10px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(15, 23, 42, 0.04);
        }
        label {
            font-weight: 600;
        }
        input, button, select, textarea {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            margin-bottom: 12px;
            border: 1px solid #cbd5f5;
            border-radius: 6px;
        }
        button {
            background: #2563eb;
            color: #fff;
            cursor: pointer;
        }
        button:disabled {
            background: #94a3b8;
            cursor: wait;
        }
        #chatbox {
            height: 340px;
            overflow-y: auto;
            padding: 12px;
            background: #f1f5f9;
            border-radius: 8px;
            border: 1px solid #d8dee9;
        }
        .msg {
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            line-height: 1.5;
        }
        .msg.user {
            background: #dbeafe;
            text-align: right;
        }
        .msg.ai {
            background: #dcfce7;
        }
        .notes {
            background: #f8fafc;
            border: 1px solid #dde3f5;
            border-radius: 8px;
            padding: 12px;
        }
        .notes h3 {
            margin-top: 0;
        }
        ul {
            padding-left: 20px;
        }
        small {
            color: #475569;
        }
    </style>
</head>
<body>
    <h1>Learning Companion</h1>
    <p>Ingest YouTube lectures, read AI-generated notes, and chat with the content to reinforce your learning.</p>

    <div class="section">
        <h2>API Key</h2>
        <label for="apiKey">X-API-Key</label>
        <input type="text" id="apiKey" placeholder="Enter your API key" value="test-key" />
        <small>Use an API key defined in your <code>.env</code>.</small>
    </div>

    <div class="section">
        <h2>1. Add Study Material</h2>
        <form id="youtubeForm">
            <label for="youtubeUrl">YouTube URL</label>
            <input type="text" id="youtubeUrl" placeholder="https://youtube.com/watch?v=..." required />
            <button type="submit" id="youtubeBtn">Enqueue YouTube Video</button>
        </form>
        <hr />
        <form id="pdfForm">
            <label for="pdfFile">PDF Upload</label>
            <input type="file" id="pdfFile" accept=".pdf" />
            <button type="submit" id="pdfBtn">Process PDF</button>
        </form>
        <p id="processStatus"></p>
    </div>

    <div class="section">
        <h2>2. Video Library</h2>
        <label for="videoSelect">Your videos</label>
        <select id="videoSelect">
            <option value="">-- Select a processed video --</option>
        </select>
        <div id="notesPanel" class="notes" hidden>
            <h3 id="notesTitle"></h3>
            <p id="notesSummary"></p>
            <h4>Key Points</h4>
            <ul id="notesKeyPoints"></ul>
            <h4>Timeline Highlights</h4>
            <ul id="notesTimeline"></ul>
            <h4>Quiz Starters</h4>
            <ul id="notesQuiz"></ul>
        </div>
    </div>

    <div class="section">
        <h2>3. Chat with Your Notes</h2>
        <div id="chatbox"></div>
        <form id="chatForm">
            <textarea id="chatInput" placeholder="Ask a question about the selected video" rows="3" required></textarea>
            <button type="submit" id="chatBtn">Send</button>
        </form>
    </div>

    <script>
        const threadId = 'session_' + Math.random().toString(36).substr(2, 9);
        let currentVideoId = '';
        const chatbox = document.getElementById('chatbox');
        const processStatus = document.getElementById('processStatus');
        const videoSelect = document.getElementById('videoSelect');
        const notesPanel = document.getElementById('notesPanel');
        const notesTitle = document.getElementById('notesTitle');
        const notesSummary = document.getElementById('notesSummary');
        const notesKeyPoints = document.getElementById('notesKeyPoints');
        const notesTimeline = document.getElementById('notesTimeline');
        const notesQuiz = document.getElementById('notesQuiz');

        const getHeaders = (json = false) => {
            const headers = { 'X-API-Key': document.getElementById('apiKey').value };
            if (json) headers['Content-Type'] = 'application/json';
            return headers;
        };

        async function refreshLibrary() {
            try {
                const response = await fetch('/videos/', { headers: getHeaders() });
                if (!response.ok) throw new Error('Unable to load library');
                const data = await response.json();
                const selected = videoSelect.value;
                videoSelect.innerHTML = '<option value="">-- Select a processed video --</option>';
                (data.videos || []).forEach((item) => {
                    const option = document.createElement('option');
                    option.value = item.video_id;
                    option.textContent = `${item.title || item.video_id}`;
                    videoSelect.appendChild(option);
                });
                if (selected) {
                    videoSelect.value = selected;
                    if (videoSelect.value === selected) {
                        currentVideoId = selected;
                        await loadNotes(selected);
                    }
                }
            } catch (error) {
                console.error(error);
            }
        }

        async function loadNotes(videoId) {
            if (!videoId) {
                notesPanel.hidden = true;
                currentVideoId = '';
                return;
            }
            try {
                const response = await fetch(`/videos/${videoId}/notes`, { headers: getHeaders() });
                if (!response.ok) throw new Error('Unable to load notes');
                const data = await response.json();
                notesTitle.textContent = data.title || 'Untitled video';
                notesSummary.textContent = data.summary || 'No summary available yet.';
                renderList(notesKeyPoints, data.key_points || []);
                renderList(notesTimeline, (data.timeline || []).map((item) => `${item.timestamp}s — ${item.note}`));
                renderList(notesQuiz, (data.quiz || []).map((item) => `${item.question} → ${item.answer}`));
                notesPanel.hidden = false;
                currentVideoId = videoId;
            } catch (error) {
                notesPanel.hidden = true;
                processStatus.innerText = `Error: ${error.message}`;
            }
        }

        function renderList(node, items) {
            node.innerHTML = '';
            if (!items || !items.length) {
                const li = document.createElement('li');
                li.textContent = 'No data available yet.';
                node.appendChild(li);
                return;
            }
            items.forEach((item) => {
                const li = document.createElement('li');
                li.textContent = item;
                node.appendChild(li);
            });
        }

        async function pollIngest(jobId) {
            processStatus.innerText = `Job ${jobId} queued...`;
            let done = false;
            while (!done) {
                await new Promise(r => setTimeout(r, 2000));
                const res = await fetch(`/ingest/status/${jobId}`, { headers: getHeaders() });
                if (!res.ok) {
                    processStatus.innerText = `Failed to fetch status (${res.status})`;
                    return;
                }
                const data = await res.json();
                processStatus.innerText = `Job ${data.job_id}: ${data.state}`;
                if (data.state === 'SUCCESS' || data.state === 'FAILURE') {
                    done = true;
                    if (data.state === 'SUCCESS') {
                        processStatus.innerText = `Job ${data.job_id} finished. Indexed ${data.text_chunks_indexed || 0} text chunks and ${data.images_indexed || 0} images.`;
                        await refreshLibrary();
                    } else {
                        processStatus.innerText = `Job ${data.job_id} failed: ${data.error || data.result || 'unknown error'}`;
                    }
                }
            }
        }

        document.getElementById('youtubeForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const url = document.getElementById('youtubeUrl').value;
            const btn = document.getElementById('youtubeBtn');
            const formData = new FormData();
            formData.append('url', url);

            btn.disabled = true;
            processStatus.innerText = 'Enqueuing YouTube ingestion...';

            try {
                const response = await fetch('/process-youtube/', {
                    method: 'POST',
                    headers: getHeaders(),
                    body: formData,
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.detail || 'Ingestion failed');
                }
                processStatus.innerText = `Job ${result.job_id} accepted. Tracking...`;
                await pollIngest(result.job_id);
                document.getElementById('youtubeUrl').value = '';
            } catch (error) {
                processStatus.innerText = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        });

        document.getElementById('pdfForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('pdfFile');
            if (!fileInput.files.length) {
                processStatus.innerText = 'Select a PDF first.';
                return;
            }
            const btn = document.getElementById('pdfBtn');
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);

            btn.disabled = true;
            processStatus.innerText = 'Processing PDF...';

            try {
                const response = await fetch('/process-pdf/', {
                    method: 'POST',
                    headers: getHeaders(),
                    body: formData,
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.detail || 'Processing failed');
                }
                processStatus.innerText = `Indexed ${result.text_chunks_indexed} text chunks and ${result.images_indexed} images.`;
                fileInput.value = '';
            } catch (error) {
                processStatus.innerText = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        });

        document.getElementById('chatForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) {
                return;
            }
            const btn = document.getElementById('chatBtn');

            input.value = '';
            btn.disabled = true;

            addMessage(message, 'user');

            try {
                const response = await fetch('/chat/', {
                    method: 'POST',
                    headers: getHeaders(true),
                    body: JSON.stringify({ thread_id: threadId, message, video_id: currentVideoId || null }),
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.detail || 'Chat failed');
                }
                addMessage(formatAssistantMessage(result), 'ai');
            } catch (error) {
                addMessage(`Error: ${error.message}`, 'ai');
            } finally {
                btn.disabled = false;
            }
        });

        videoSelect.addEventListener('change', async (event) => {
            await loadNotes(event.target.value);
        });

        function addMessage(text, role) {
            const div = document.createElement('div');
            div.className = `msg ${role}`;
            div.innerHTML = text;
            chatbox.appendChild(div);
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        function formatAssistantMessage(result) {
            const parts = [result.response || ''];
            if (result.citations) {
                const textSources = (result.citations.text || []).map((c) => c.source || c.file_name || 'text');
                const imageSources = (result.citations.images || []).map((c) => c.source || 'image');
                if (textSources.length) parts.push(`<small>Text: ${textSources.join(', ')}</small>`);
                if (imageSources.length) parts.push(`<small>Images: ${imageSources.join(', ')}</small>`);
            }
            return parts.join('<br/>');
        }

        (async () => {
            await refreshLibrary();
        })();
    </script>
</body>
</html>
